# This script will perform a clustering of elements based on their
# distance.
#
# input : "distance": either a full m*m distance matrix or the upper
#                     triangular matrix of m*(m-1)/2 elements
#         "minClusters": the minimum desired number of clusters
#         "maxClusters": the minimum desired number of clusters
#         "m"       : the number of elements to cluster
#
# output: "clusters": the assignment of instances to clusters 
#         "quality" : the quality measure
#
safeExec({#
if( (m > 1) && (minClusters < m) ) {#
#
# 0. load packages
hasPackageStats<-safeUsePackage("stats");
#
# 1. Building Distance Matrix
dimDist<-dim(distance);
#
if((m != 1) && ((dimDist[1]==1) || (dimDist[2]==1))) {
  # Only a distance vector was supplied.
  # We transform it first to a full distance matrix, then
  # to a `dist` object.
  distanceMatrix <- matrix(NA, ncol=m, nrow=m);
  distanceMatrix[lower.tri(distanceMatrix)] <- distance;
  distance <- as.dist(distanceMatrix);
  rm(distanceMatrix);
} else {
  # A full distance matrix was supplied, transform to `dist`
  # object directly.
  distance <- as.dist(distance);
}# / distance matrix building
#
## 2. Clustering Step
#
## 2.1. Use Partitioning Around Medoids
if(minClusters >= maxClusters) {#
  if(safeUsePackage("cluster")) {
    safeExec(pamResult<-pam(x=distance, k=minClusters, diss=TRUE));
  }
} else {
  if(safeUsePackage("fpc")) {
    safeExec(pamResult<-pamk(data=distance, krange=minClusters:min(m-1,maxClusters), diss=TRUE)$pamobject);  
  }
}
if(exists("pamResult")) {
  clusters<-as.vector(pamResult$clustering);
  if(exists("clusters")) {
    safeExec(quality<-as.double(pamResult$silinfo$avg.width));
    rm(pamResult);
    if( exists("quality") && ( (length(quality) <= 0) || (quality < -1) || (quality > 1) ) ) {
      rm(quality);
    }
    if( (!(exists("quality"))) && (max(clusters) > 1) ) {
      safeExec(quality<-as.double(cluster.stats(d=distance, clustering=clusters)$avg.silwidth))
    }
    if( (!(exists("quality"))) || (length(quality) <= 0) || (quality < -1) || (quality > 1) ) {
      quality <- as.double(-1);
    }
  }
}
#
## 2.2. Use Hierarchical Clustering
if(hasPackageStats) {
  safeExec({#
    hclustList <- list(#
      hclust(distance, method="centroid"),#
      hclust(distance, method="ward.D"),#
      hclust(distance, method="ward.D2"),#
      hclust(distance, method="single"),#
      hclust(distance, method="complete"),#
      hclust(distance, method="average"),#
      hclust(distance, method="mcquitty"),#
      hclust(distance, method="median"));#
#
      for(i in minClusters:min(m-1,maxClusters)) {#
        for(hres in hclustList) {#
          safeExec({ hclustering <- as.vector(cutree(hres, k=i)); })
          if(exists("hclustering")) {            
            if(max(hclustering) > 1) {
              hquality <- safeExec({ as.double(cluster.stats(d=distance, clustering=hclustering)$avg.silwidth); })#
            }
            if( (!(exists("hquality"))) || (length(hquality) <= 0) || (hquality < -1) || (hquality > 1) ) {
              hquality <- as.double(-1);
            }
            if( (!(exists("clusters"))) || (!(exists("quality")))  || (hquality > quality) ) {#
              quality<-hquality;#
              clusters<-hclustering;#
            }            
            rm(hquality);            
            rm(hclustering);
          }#
        }#
      }#
    });
#
  safeExec( { rm(hclustering); rm(hquality); } )
}
#
}# / clusterable data
#
})# / safe exec wrapper
# fallback
if( (!(exists("clusters"))) || (!(is.vector(clusters))) ) {
  if((minClusters > 0) && (minClusters < m)) {
    clusters <- c(rep(1, m-minClusters), 1:minClusters);    
  } else {
    if((maxClusters > 0) && (maxClusters < m)) {
      clusters <- c(rep(1, m-maxClusters), 1:maxClusters);    
    } else {
      clusters <- 1:m;
    }
  }
}
if( (!(exists("quality"))) || (!(is.double(quality)))) {
  quality  <- as.double(1);
} else {
  quality  <- as.double(max(0, min(1, (1.0-quality))));
}