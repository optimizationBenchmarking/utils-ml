# This script will perform a clustering of elements based on their
# distance.
#
# input : "distance": either a full m*m distance matrix or the upper
#                     triangular matrix of m*(m-1)/2 elements
#         "minClusters": the minimum desired number of clusters
#         "maxClusters": the minimum desired number of clusters
#         "m"       : the number of elements to cluster
#
# output: "clusters": the assignment of instances to clusters 
#         "quality" : the quality measure
#
safeExec({#
if( (m > 1) && (minClusters < m) ) {#
#
# 1. Building Distance Matrix
dimDist<-dim(distance);
#
if((m != 1) && ((dimDist[1]==1) || (dimDist[2]==1))) {
  # Only a distance vector was supplied.
  # We transform it first to a full distance matrix, then
  # to a `dist` object.
  distanceMatrix <- matrix(NA, ncol=m, nrow=m);
  distanceMatrix[lower.tri(distanceMatrix)] <- distance;
  distance <- as.dist(distanceMatrix);
  rm(distanceMatrix);
} else {
  # A full distance matrix was supplied, transform to `dist`
  # object directly.
  distance <- as.dist(distance);
}# / distance matrix building
#
## 2. Clustering Step
## 2.1. set up range of validclusters
clusterRange <- minClusters:maxClusters;
#
## 2.2. Use Partitioning Around Medoids
if(nCluster > 0) {#
  if(safeUsePackage("cluster")) {
    safeExec(pamResult<-pam(x=distance, k=nCluster, diss=TRUE));
  }
} else {
  if(safeUsePackage("fpc")) {
    safeExec(pamResult<-pamk(data=distance, krange=clusterRange, diss=TRUE)$pamobject);  
  }
}
if(exists("pamResult")) {
  clusters<-as.vector(pamResult$clustering);#
  quality <-as.double(pamResult$silinfo$avg.width);#
}
#
## 2.3. Use Hierarchical Clustering
if(safeUsePackage("stats")) {
  safeExec({#
    hclustList <- list(#
      hclust(distance, method="centroid"),#
      hclust(distance, method="ward.D"),#
      hclust(distance, method="ward.D2"),#
      hclust(distance, method="single"),#
      hclust(distance, method="complete"),#
      hclust(distance, method="average"),#
      hclust(distance, method="mcquitty"),#
      hclust(distance, method="median"));#
    #
      for(i in clusterRange) {#
        for(hres in hclustList) {#
          hclustering <- as.vector(cutree(hres, k=i));#
          if(max(hclustering) > 1) {
            hquality <- as.double(cluster.stats(d=distance, clustering=hclustering)$avg.silwidth);#
          } else {#
            hquality <- -1;
          }#
          if((!(exists("clusters"))) ||
             (!(exists("quality")))  || (hquality > quality)) {#
            if(hquality<0) {#
              quality <- (-Inf);
            } else {#
              quality <- hquality;#
            }#
            clusters  <- hclustering;#
          }#
        }#
      }#
    });
#
  safeExec( { rm(hclustering); rm(hquality); } )
}
#
}# / clusterable data
#
})# / safe exec wrapper
# fallback
if( (!(exists("clusters"))) || (!(exists("quality"))) ||
    (!(is.vector(clusters))) || (!(is.double(quality)))) {
  if((nCluster > 0) && (nCluster < m)) {
    clusters <- c(rep(1, m-nCluster), 1:nCluster);
  } else {
    clusters <- 1:m;
  }
  quality  <- as.double(1);
} else {
  quality  <- (1.0-quality);
}