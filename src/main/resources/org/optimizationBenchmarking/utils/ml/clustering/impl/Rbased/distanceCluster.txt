# This script will perform a clustering of elements based on their
# distance.
#
# input : "distance": either a full m*m distance matrix or the upper
#                     triangular matrix of m*(m-1)/2 elements
#         "minClusters": the minimum desired number of clusters
#         "maxClusters": the minimum desired number of clusters
#         "m"       : the number of elements to cluster
#
# output: "clusters": the assignment of instances to clusters 
#         "quality" : the quality measure
#
safeExec({#
if( (m > 1) && (minClusters < m) ) {#
#
# 0. load packages
hasPackageStats<-safeUsePackage("stats");
#
# 1. Building Distance Matrix
dimDist<-dim(distance);
#
if((m != 1) && ((dimDist[1]==1) || (dimDist[2]==1))) {
  # Only a distance vector was supplied.
  # We transform it first to a full distance matrix, then
  # to a `dist` object.
  distanceMatrix <- matrix(NA, ncol=m, nrow=m);
  distanceMatrix[lower.tri(distanceMatrix)] <- distance;
  distance <- as.dist(distanceMatrix);
  rm(distanceMatrix);
} else {
  # A full distance matrix was supplied, transform to `dist`
  # object directly.
  distance <- as.dist(distance);
}# / distance matrix building
#
## 2. Clustering Step
#
## 2.1. Use Partitioning Around Medoids
if(minClusters >= maxClusters) {#
  if(safeUsePackage("cluster")) {
    safeExec(pamResult<-pam(x=distance, k=minClusters, diss=TRUE));
  }
} else {
  if(safeUsePackage("fpc")) {
    safeExec(pamResult<-pamk(data=distance, krange=minClusters:min(m-1,maxClusters), diss=TRUE)$pamobject);  
  }
}
if(exists("pamResult")) {
  clusters<-as.vector(pamResult$clustering);#
  safeExec( { rm(pamResult) } );
  if(max(clusters) > 1) {
    safeExec({ quality <- cluster.stats(d=distance, clustering=clusters)$avg.silwidth; })
  }
  if(exists("quality")) {
    if(length(quality) <= 0) {
      quality <- as.double(0);    
    }
    if(quality > 1) {
      quality <- as.double(0.01);
    }
  } else {
    quality <- as.double(0);    
  }
}
#
## 2.2. Use Hierarchical Clustering
if(hasPackageStats) {
  safeExec({#
    hclustList <- list(#
      hclust(distance, method="centroid"),#
      hclust(distance, method="ward.D"),#
      hclust(distance, method="ward.D2"),#
      hclust(distance, method="single"),#
      hclust(distance, method="complete"),#
      hclust(distance, method="average"),#
      hclust(distance, method="mcquitty"),#
      hclust(distance, method="median"));#
#
      for(i in minClusters:min(m-1,maxClusters)) {#
        for(hres in hclustList) {#
          hclustering <- as.vector(cutree(hres, k=i));#
          if(max(hclustering) > 1) {
            hquality <- as.double(cluster.stats(d=distance, clustering=hclustering)$avg.silwidth);#
          } else {#
            hquality <- as.double(0);
          }#
          if(hquality > 1) {
            hquality <- as.double(0.01);
          }
          if((!(exists("clusters"))) ||
             (!(exists("quality")))  || (hquality > quality)) {#
            quality <- hquality;#
            clusters  <- hclustering;#
          }#
        }#
      }#
    });
#
  safeExec( { rm(hclustering); rm(hquality); } )
}
#
}# / clusterable data
#
})# / safe exec wrapper
# fallback
if( (!(exists("clusters"))) || (!(is.vector(clusters))) ) {
  if((nCluster > 0) && (nCluster < m)) {
    clusters <- c(rep(1, m-nCluster), 1:nCluster);
  } else {
    clusters <- 1:m;
  }
}
if( (!(exists("quality"))) || (!(is.double(quality)))) {
  quality  <- as.double(1);
} else {
  quality  <- as.double(max(0, min(1, (1.0-quality))));
}